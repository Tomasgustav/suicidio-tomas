/ *! jQuery v3.1.1 | (c) Fundación jQuery | jquery.org/license * /
0, toArray: function () {return f.call (this)}, get: function (a) {return null == a? F.call (this): a <0? This [a + this.length]: this [a]}, pushStack: function (a) {var b = r.merge (this.constructor (), a); return b.prevObject = this, b}, each: function (a) {return r.each (this, a)}, map: function (a) {return this.pushStack (r.map (this, function (b, c) {return a.call (b, c, b)}))}, slice: function () {return this.pushStack (f.apply (this, argumentos))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)} , eq: function (a) {var b = this.length, c = + a + (a <0? b: 0); devuelva this.pushStack (c> = 0 && c <b? [this [c]]: [] )}, end: function () {return this.prevObject || this.constructor ()}, push: h, sort: c.sort, splice: c.splice}, r.extend = r.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = argumentos.longitud, j =! 1; para ("boolean" == typeof g && (j = g, g = argumentos [h] || {}, h ++), "object "== typeof g || r.isFunction (g) || (g = {}), h === i && (g = this, h -); h <i; h ++) if (null! = ( a = argumentos [h])) para (b en a) c = g [b], d = a [b], g! == d && (j && d && (r.isPlainObject (d) || (e = r.isArray) (d)))? (e? (e =! 1, f = c && r.isArray (c)? c: []): f = c && r.isPlainObject (c)? c: {}, g [b] = r .extender (j, f, d)): void 0! == d && (g [b] = d)); return g}, r.extend ({expando: "jQuery" + (q + Math.random () ) .replace (/ \ D / g, ""), isReady:! 0, error: function (a) {lanza un nuevo error (a)}, noop: function () {}, isFunction: function (a) {return "function" === r.type (a)}, isArray: Array.isArray, isWindow: function (a) {return null! = a && a === a.window}, esNumeric: function (a) {var b = r.type (a); return ("número" === b || "cadena" === b) &&! isNaN (a-parseFloat (a))}, isPlainObject: function (a) {var b, c ; return! (! a || "[object Object]"! == k.call (a)) && (! (b = e (a)) || (c = l.call (b, "constructor") && b.constructor, "function" == typeof c && m.call (c) === n))}, isEmptyObject: function (a) {var b; para (b in a) return! 1; return! 0}, escriba: function (a) {return null == a? a + "": "object" == typeof a || "function" == typeof a? j [k.call (a)] || "object": typeof a}, globalEval: function (a) {p (a)}, camelCase: function ( a) {return a.replace (t, "ms -"). replace (u, v)}, nodeName: function (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ( )}, cada una: función (a, b) {var c, d = 0; if (w (a)) {para (c = a.length; d <c; d ++) if (b.call (a [d ], d, a [d]) ===! 1) break} else para (d en a) if (b.call (a [d], d, a [d]) ===! 1) break; return a}, trim: function (a) {return null == a? "" :( a + ""). replace (s, "")}, makeArray: function (a, b) {var c = b || []; return null! = a &&(w (Object (a))? r.merge (c, "string" == typeof a? [a]: a): h.call (c, a)), c}, inArray: function (a, b , c) {return null == b? -1: i.call (b, a, c)}, merge: function (a, b) {for (var c = + b.length, d = 0, e = a.length; d <c; d ++) a [e ++] = b [d]; devuelve a.length = e, a}, grep: function (a, b, c) {para (var d, e = [] , f = 0, g = a. longitud, h =! c; f <g; f ++) d =! b (a [f], f), d! == h && e.push (a [f]); return e}, mapa: función (a, b, c) {var d, e, f = 0, h = []; if (w (a)) para (d = a.length; f <d; f ++) e = b (a [f], f, c), null! = e && h.push (e); otra cosa para (f en a) e = b (a [f], f, c), null! = e && h.push (e); devuelva g.apply ([], h)}, guid: 1, proxy: function (a, b) {var c, d, e; if ("string" == typeof b && (c = a [ b], b = a, a = c), r.isFunction (a)) devuelve d = f.call (argumentos, 2), e = function () {return a.apply (b || this, d.concat (f.call (argumentos)))}, e.guid = a.guid = a.guid || r.guid ++, e}, ahora: Date.now, support: o}), "function" == typeof Symbol && (r.seleccionado | seleccionado | async | autofocus | reproducción automática | controles | diferir | deshabilitado | oculto | ismap | loop | multiple | abierto | readonly | required | scoped ", K =" [\\ x20 \\ t \\ r \\ n \ \ f] ", L =" (?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) + ", M =" \\ ["+ K +" * (" + L + ") (?:" + K + "* ([* ^ $ |! ~]? =)" + K + "* (?: '((?: \\\\. | [^ \\\\' ]) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + L + "))))" + K + "* \\] ", N =" :( "+ L +") (?: \\ (((((?? \\\\. | [^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\ "]) *) \") | ((?: \\\\. | [^ \\\\ () [\\]] | "+ M +" ) *) |. *) \\) |) ", O = new RegExp (K +" + "," g "), P = new RegExp (" ^ "+ K +" + | ((?: ^ | [^ \\\\]) (?: \\\\.) *) "+ K +" + $ "," g "), Q = new RegExp (" ^ "+ K +" *, "+ K +" * ") , R = new RegExp ("^" + K + "* ([> + ~] |""i")}, W = / ^ (?: input | select | textarea | button) $ / i, X = / ^ h \ d $ / i, Y = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, $ = / [+ ~] /, _ = nuevo RegExp ("\\\\ ([\\ da-f] {1,6}" + K + "? | (" + K + ") |.)", "ig"), aa = function (a, b, c) {var d = "0x" + b-65536; retorno d! == d || c? b: d <0? String.fromCharCode (d + 65536): String.fromCharCode (d> > 10 | 55296,1023 & d | 56320)}, ba = / ([\ 0- \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ca = función (a, b) {return b? "\ 0" === a? "\ ufffd": a.slice (0, -1) + "\\" + a.charCodeAt ( a.length-1) .toString (16) + "": "\\" + a}, da = function () {m ()}, ea = ta (function (a) {return a.disabled === ! 0 && ("formulario" en una || "etiqueta" en a)}, {dir: "parentNode", siguiente: "legend"}); intente {G.apply (D = H.call (v.childNodes), v.childNodes), D [v.childNodes.length].prueba (a))) {if (1! == w) s = b, r = a; si no ("object"! == b.nodeName.toLowerCase ()) {(k = b.getAttribute ("id "))? k = k.replace (ba, ca): b.setAttribute (" id ", k = u), o = g (a), h = o.length; while (h -) o [h ] = "#" + k + "" + sa (o [h]); r = o.join (","), s = $. test (a) && qa (b.parentNode) || b} if (r ) intente {return G.apply (d, s.querySelectorAll (r)), d} catch (x) {} finalmente {k === u && b.removeAttribute ("id")}}} return i (a.replace ( P, "$ 1"), b, d, e)} función ha () {var a = []; función b (c, e) {return a.push (c + "")> d.cacheLength && delete b [a. shift ()], b [c + ""] = e} return b} function ia (a) {return a [u] =! 0, a} function ja (a) {var b = n.createElement ("fieldset" ); intente {return !! a (b)} catch (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b), b = null}} function ka (a, b) {var c = a.split ("|"), e = c.length; while (e -) d.attrHandle [c [e]] = b} función la (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex -b.sourceIndex; if (d) devuelve d; if (c) while (c = c.nextSibling) if (c === b) return-1; return a? 1: -1} function ma (a) { function de retorno (b) {var c = b.nodeName.toLowerCase (); return "input" === c && b.type === a}} function na (a) {return function (b) {var c = b. nodeName.toLowerCase (); return ("input" === c || "button" === c) && b.type === a}} function oa (a) {return function (b) {return "form" en b? b.parentNode && b.disabled ===! 1? "label" en b? "label" en b.parentNode? b.parentNode.disabled === a: b.disabled === a: b.isDisabled = == a || b.isDisabled! ==! a && ea (b) === a: b.disabled === a: "label" en b && b.disabled === a}} función pa (a) {return ia (función (b) {return b = + b,ia (función (c, d) {var e, f = a ([], c.length, b), g = f.length; mientras que (g -) c [e = f [g]] && (c [e] =! (d [e] = c [e]))})} función qa (a) {devuelve a && "undefined"! = typeof a.getElementsByTagName && a} c = ga.support = {}, f = ga.isXML = función (a) {var b = a && (a.ownerDocument || a) .documentElement; return !! b && "HTML"! == b.nodeName}, m = ga.setDocument = function (a) {var b, e, g = a? a.ownerDocument || a: v; devolver g! == n && 9 === g.nodeType && g.documentElement? (n = g, o = n.documentElement, p =! f ( n), v! == n && (e = n.defaultView) && e.top! == e && (e.addEventListener? e.addEventListener ("descargar", da,! 1): e.attachEvent && e.attachEvent ("onunload" , da)), c.attributes = ja (function (a) {return a.className = "i",! a.getAttribute ("className")}), c.getElementsByTagName = ja (function (a) {return a .appendChild (n.'> <option selected =' '> </option> </select> ", a.querySelectorAll (" [msallowcapture ^ =' '] "). length && q.push (" [* ^ $] = "+ K +" * (?: '' | \ "\") "), a.querySelectorAll (" [selected] "). length || q.push (" \\ ["+ K +" * (?: value | "+ J +" ) "), a.querySelectorAll (" [id ~ = "+ u +" -] "). length || q.push (" ~ = "), a.querySelectorAll (": checked "). length || q. push (": checked"), a.querySelectorAll ("a #" + u + "+ *"). length || q.push (". #. + [+ ~]")}), ja (función (a) {a.innerHTML = "<a href='' disabled='disabled'> </a> <select disabled = 'disabled'> <option /> </select>"; var b = n.createElement ("input" ); b.setAttribute ("type", "oculto "), a.appendChild (b) .setAttribute (" name "," D "), a.querySelectorAll (" [name = d] "). length && q.push (" name "+ K +" * [* ^ $ |! ~]? = "), 2! == a.querySelectorAll (": enabled "). Length && q.push (": enabled ",": disabled "), o.appendChild (a) .disabled =! 0, 2! == a.querySelectorAll (": disabled"). Length && q.push (": enabled", ": disabled"), a.querySelectorAll ("* ,: x"), q.push (",. *: ")})), (c.matchesSelector = Y.test (s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) &&j (función (a) {c .disconnectedMatch = s.call (a, "*"), s.call (a, "[s! = '']: x"), r.push ("! =", N)}), q = q .length && nuevo RegExp (q.join ("|")), r = r.length && nuevo RegExp (r.f) devuelve a === n? -1: b === n? 1: e? -1: f? 1: k? I (k, a) -I (k, b): 0; if (e === f) devuelve la (a, b); c = a; mientras que (c = c.parentNode) g.unshift (c); c = b; while (c = c.parentNode) h.unshift (c) ; mientras que (g [d] === h [d]) d ++; return d? la (g [d], h [d]): g [d] === v? -1: h [d] = == v? 1: 0}, n): n}, ga.matches = function (a, b) {return ga (a, null, null, b)}, ga.matchesSelector = function (a, b) { if ((a.ownerDocument || a)! == n && m (a), b = b.replace (S, "= '$ 1']"), c.matchesSelector && p &&! A [b + ""] && (! r | |! r.test (b)) && (! q ||! q.test (b))) intente {var d = s.call (a, b); if (d || c.disconnectedMatch || a. document && 11! == a.document.nodeType) return d} catch (e) {} return ga (b, n, null, [a]). length> 0}, ga.contains = function (a, b) {return (a.ownerDocument || a)! == n && m (a), t (a, b)}, ga.attr = función (a, b) {(a.ownerDocument || a)! == n && m (a) ; var e = d.attrHandle [b.toLowerCase ()], f = e && C.call (d.V, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", primero:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", primero:! 0}, "~": {dir: "previousSibling"}}, prefiltro: {ATTR: function (a) {return a [1] = a [1] .replace (_, aa) , a [3] = (a [3] || a [4] || a [5] || "") .emplace (_, aa), "~ =" === a [2] && (a [3] = "" + a [3] + ""), a.slice (0,4)}, CHILD: function (a) {return a [1] = a [1] .toLowerCase (), "nth "=== a [1] .slice (0,3)? (a [3] || ga.error (a [0]), a [4] = + (a [4]? a [5] + (a [6] || 1): 2 * ("even" === a [3] || "odd" === a [3])), a [5] = + (a [7] + a [8] || "impar" === a [3])): a [3] && ga.error (a [0]), a}, PSEUDO: función (a) {var b, c =! a [6] && a [2]; return V.CHILD.test (a [0])? Null: (a [3]? A [2] = a [4] || a [5] || "": c && T .test (c) && (b = g (c,! 0)) &&(b = c.indexOf (")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c.slice ( 0, b)), a.slice (0,3))}}, filter: {TAG: function (a) {var b = a.replace (_, aa) .toLowerCase (); return "*" == = a? function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASS: function (a) {var b = y [a + ""] ; return b || (b = new RegExp ("(^ |" + K + ")" + a + "(" + K + "| $)")) && y (a, function (a) {return b.test (" string "== typeof a.className && a.className ||" undefined "! = typeof a.getAttribute && a.getAttribute (" class ") ||" ")))}, ATTR: function (a, b, c) {return function (d) {var e = ga.attr (d, a); return null == e? "! =" === b:! b || (e + = "", "=" === b? e === c: "! =" === b? e! == c: "^ =" === b? c && 0 === e.indexOf (c): "* ="toLowerCase ())? ia (función (a, c) {var d, f = e (a, b), g = f.length; mientras que (g -) d = I (a, f [g]), a [d] =! (c [d] = f [g])}): function (a) {return e (a, 0, c)}): e}}, pseudos: {not: ia (function ( a) {var b = [], c = [], d = h (a.replace (P, "$ 1")); devolver d [u]? ia (función (a, b, c, e) {var f, g = d (a, nulo, e, []), h = a.length; mientras que (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): función (a, e, f) {return b [0] = a, d (b, null, f, c), b [0] = null,! c.pop ()}}) , tiene: ia (función (a) {return function (b) {return ga (a, b) .length> 0}}), contiene: ia (function (a) {return a = a.replace (_, aa ), function (b) {return (b.textContent || b.innerText || e (b)). indexOf (a)> - 1}}), lang: ia (function (a) {return U.test ( a || "") || ga.error ("lang no compatible:" + a), a = a.replace (_, aa) .toLowerCase (), function (b) {var c; do if (c = p ? b.lang: b.getAttribute ("xml: lang") || b.getAttribute ("lang")) devuelve c = c.toLowerCase (), c === a || 0 === c.indexOf (a + "-"); while ((b = b.parentNode) && 1 === b.nodeType); return! 1}}), target: function (b) {var c = a.location && a.location.hash ; return c && c.slice (1) === b.id}, root: function (a) {return a === o}, focus: function (a) {return a === n.activeElement && (! n. hasFocus || n.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)} habilitado: oa (! 1), deshabilitado: oa (! 0), marcado: función ( a) {var b = a.nodeName.toLowerCase (); devolver "input" === b && !! a.checked || "option" === b && !! a.selected}, selected: function (a) { devuelve a.parentNode && a.parentNode.selectedIndex, a.selected ===! 0}, empty: function (a) {for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType <6) return! 1; return! 0}, parent: function (a) {return! d.pseudos.empty (a)}, header: function (a) {return X.test (a.nodeName)}, input: function ( a) {return W.test (a.nodeName)}, botón:function (a) {var b = a.nodeName.toLowerCase (); devolver "input" === b && "button" === a.type || "button" === b}, text: function (a) {var b; devolver "input" === a.nodeName.toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("type")) || "text" = == b.toLowerCase ())}, primero: pa (function () {return [0]}), last: pa (function (a, b) {return [b-1]}), eq: pa (function (a, b, c) {return [c <0? c + b: c]}), par: pa (función (a, b) {para (var c = 0; c <b; c + = 2) a .push (c); devolver a}), impar: pa (función (a, b) {para (var c = 1; c <b; c + = 2) a.push (c); devolver a}), lt : pa (función (a, b, c) {para (var d = c <0? c + b: c; - d> = 0;) a.push (d); devolver a}), gt: pa (función (a, b, c) {para (var d = c <0? c + b: c; ++ d <b;) a.push (d); return a})}}, d.pseudos. nth = d.pseudos.eq; para (b en {radio:! 0, casilla de verificación:! 0, archivo:! 0, contraseña:! 0, imagen:! 0}) d.pseudos [b] = ma (b) ; para (b en {submit:! 0,nodeType || g) devuelve a (b, c, e); return! 1}: función (b, c, i) {var j, k, l, m = [w, h]; if (i) {while (b = b [d]) si ((1 === b.nodeType || g) && a (b, c, i)) devuelve! 0} else while (b = b [d]) if (1 == = b.nodeType || g) si (l = b [u] || (b [u] = {}), k = l [b.uniqueID] || (l [b.uniqueID] = {}), e && e === b.nodeName.toLowerCase ()) b = b [d] || b; else {if ((j = k [f]) ​​&& j [0] === w && j [1] === h) devuelve m [2] = j [2]; if (k [f] = m, m [2] = a (b, c, i)) return! 0} return! 1}} function ua (a) {return a.length> 1? function (b, c, d) {var e = a.length; while (e -) if (! a [e] (b, c, d)) return! 1; return! 0 }: a [0]} función va (a, b, c) {para (var d = 0, e = b.length; d <e; d ++) ga (a, b [d], c); retorno c } función wa (a, b, c, d, e) {para (var f, g = [], h = 0, i = a.length, j = null! = b; h <i; h ++) (f = a [h]) && (c &&! c (f, d, e) || (g.push (f), j && b.push (h))); return g} función xa (a, b, c, d , e, f) {devolver d &&! d [u] && (d = xa (d)), e &&! e [u] && (e = xa (e, f)),ia (función (f, g, h, i) {var j, k, l, m = [], n = [], o = g.length, p = f || va (b || "*", h.nodeType? [h]: h, []), q =! a ||! f && b? p: wa (p, m, a, h, i), r = c? e || (f? a: o || d)? []: g: q; if (c && c (q, r, h, i), d) {j = wa (r, n), d (j, [], h, i), k = j.length; while (k -) (l = j [k]) && (r [n [k]] =! (q [n [k]] = l))} if (f) {if (e || a) {si (e) {j = [], k = r.length; mientras que (k -) (l = r [k]) && j.push (q [k] = l); e (nulo, r = [], j, i)} k = r.length; mientras que (k -) (l = r [k]) && (j = e? I (f, l): m [k] )> - 1 && (f [j] =! (G [j] = l))}} else r = wa (r === g? R.splice (o, r.length): r), e? E (nulo, g, r, i): G.apply (g, r)})} función ya (a) {para (var b, c, e, f = a.length, g = d.relative [a [ 0] .tipo], h = g || d.relativo [""], i = g? 1: 0, k = ta (función (a) {return a === b}, h,! 0), l = ta (función (a) {retorno I (b, a)> - 1}, h,! 0), m = [función (a, c, d) {var e =! g && (d || c! == j) || ((b = c) .nodeType? k (a, c, d): l (a, c, d)); return b = null, e}]; i <f; i ++) si (c = d. relativo [a [i].type]) m = [ta (ua (m), c)]; else {if (c = d.filter [a [i] .type] .apply (null, a [i] .matches), c [u ]) {para (e = ++ i; e <f; e ++) if (d.relative [a [e] .type]) break; devuelva xa (i> 1 && ua (m), i> 1 && sa (a.slice (0, i-1) .concat ({value: "" === a [i-2] .type? "*": ""})). Replace (P, "$ 1"), c, i < e & Y ya (a.slice (i, e)), e <f && ya (a = a.slice (e)), e <f && sa (a))} m.push (c)} devolver la función ua (m)} za ( a, b) {var c = b.length> 0, e = a.length> 0, f = función (f, g, h, i, k) {var l, o, q, r = 0, s = "0", t = f && [], u = [], v = j, x = f || e && d.find.TAG ("*", k), y = w + = null == v? 1: Math. random () || .1, z = x.length; para (k && (j = g === n || g || k); s! == z && null! = (l = x [s]); s ++ ) {if (e && l) {o = 0, g || l.ownerDocument === n || (m (l), h =! p); mientras que (q = a [o ++]) if (q (l, g || n, h)) {i.push (l); break} k && (w = y)} c && ((l =! q && l) &&parentNode), a = a.slice (i.shift (). value.length)} f = V.needsContext.test (a)? 0: i.length; while (f -) {if (j = i [ f], d.relativo [k = j.type]) break; if ((l = d.find [k]) && (e = l (j.matches [0] .replace (_, aa), $. test (i [0] .type) && qa (b.parentNode) || b))) {if (i.splice (f, 1), a = e.length && sa (i) ,! a) devuelva G.apply ( c, e), c; break}}} return (m || h (a, n)) (e, b,! p, c,! b || $ .test (a) && qa (b.parentNode) | | b), c}, c.sortStable = u.split (""). sort (B) .join ("") === u, c.detectDuplicates = !! l, m (), c.sortDetached = ja (función (a) {return 1 & a.compareDocumentPosition (n.createElement ("fieldset"))}), ja (función (a) {return a.innerHTML = "<a href='#'> </a>" , "#" === a.firstChild.getAttribute ("href")}) || ka ("type | href | height | width", función (a, b, c) {si (! c) devuelve a. getAttribute (b, "type" === b.toLowerCase ()? 1:2)}), c.attributes && ja (función (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("value", ""), "" === a.firstChild.getAttribute ("value")}) || ka ("value", function (a, b, c) {if (! c && "input" === a.nodeName.toLowerCase ()) return a.defaultValue}), ja (función (a) {return null == a.getAttribute ("disabled")}) || ka (J, función (a, b, c) {var d; si (! c) devuelve a [b] == =! 0? B.toLowerCase () :( d = a.getAttributeNode (b)) && d.specified? D.value: null}), ga} (a); r.find = x, r.expr = x. selectores, r.expr [":"] = r.expr.pseudos, r.uniqueSort = r.unique = x.uniqueSort, r.text = x.getText, r.isXMLDoc = x.isXML, r.contains = x .contains, r.escapeSelector = x.escape; var y = function (a, b, c) {var d = [], e = void 0! == c; while ((a = a [b]) && 9! == a.nodeType) if (1 === a.nodeType) {if (e && r (a) .is (c)) break; d.push (a)} return d}, z = function (a, b) {for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a) ; return c}, A = r.expr.match.needsContext, B = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i, C = / ^. [^: # \ [\.,] * $ /; función D (a , b, c) {return r.isFunction (b)? r.grep (a, function (a, d) {return !! b.call (a, d, a)! == c}): b.nodeType ? r.grep (a, función (a) {return a === b! == c}): "string"! = typeof b? r.grep (a, function (a) {return i.call (b , a)> - 1! == c}): C.test (b)? r.filter (b, a, c) :( b = r.filter (b, a), r.grep (a, función (a) {return i.call (b, a)> - 1! == c && 1 === a.nodeType}))} r.filter = función (a, b, c) {var d = b [0] ; devolver c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d.nodeType? r.find.matchesSelector (d, a)? [d]: []: r.find.matches (a, r.grep (b, function (a) {return 1 === a.nodeType}))}, r.fn.extend ({find:if (e [1]) {if (b = b instanceof r? b [0]: b, r.merge (este, r.parseHTML (e [1], b && b.nodeType? b.ownerDocument || b: d ,! 0)), B.test (e [1]) && r.isPlainObject (b)) para (e in b) r.isFunction (this [e])? This [e] (b [e]): this .attr (e, b [e]); devolver esto} return f = d.getElementById (e [2]), f && (this [0] = f, this.length = 1), this} return a.nodeType? (este [0] = a, this.length = 1, this): r.isFunction (a)? void 0! == c.ready? c.ready (a): a (r): r.makeArray (a , this)}; G.prototype = r.fn, E = r (d); var H = / ^ (?: parents | prev (?: Until | All)) /, I = {children:! 0, contents :! 0, siguiente:! 0, prev:! 0}; r.fn.extend ({tiene: función (a) {var b = r (a, esto), c = b.length; devuelva este.filter ( function () {for (var a = 0; a <c; a ++) if (r.contains (this, b [a])) return! 0})}, closest: function (a, b) {var c, d = 0, e = this.length, f = [], g = "string"! = typeof a && r (a); if (! A.test (a)) for (; d <e; d ++) for (c = este [d]; c && c! == b; c = c.parentNode) si (c.nodeType <11 && (g? g.index (c)> - 1: 1 === c.nodeType && r.find.matchesSelector (c, a))) {f.push (c); break} devuelve this.pushStack (f .length> 1? r.uniqueSort (f): f)}, index: function (a) {return a? "string" == typeof a? i.call (r (a), this [0]): i .call (esto, a.jquery? a [0]: a): este [0] && este [0] .parentNode? this.first (). prevAll (). length: -1}, add: function (a, b) {return this.pushStack (r.uniqueSort (r.merge (this.get (), r (a, b)))), addBack: function (a) {return this.add (null == a? this.prevObject: this.prevObject.filter (a))}}); función J (a, b) {while ((a = a [b]) && 1! == a.nodeType); return a} r.each ({parent: function (a) {var b = a.parentNode; return b && 11! == b.nodeType? b: null}, parents: function (a) {return y (a, "parentNode")}, parents Hasta que: function (a, b, c) {return y (a, "parentNode", c)}, next: function (a) {return J (a, "nextSibling")}, prev:function (a) {return J (a, "previousSibling")}, nextAll: function (a) {return y (a, "nextSibling")}, prevAll: function (a) {return y (a, "previousSibling") }, nextUntil: function (a, b, c) {return y (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return y (a, "previousSibling", c)}, hermanos: función (a) {return z ((a.parentNode || {}). FirstChild, a)}, children: function (a) {return z (a.firstChild)}, contents: function (a) {return a.contentDocument || r.merge ([], a.childNodes)}}, function (a, b) {r.fn [a] = function (c, d) {var e = r.map (this, b , c); devuelve "Until"! == a.slice (-5) && (d = c), d && "string" == typeof d && (e = r.filter (d, e)), this.length> 1 && (I [a] || r.uniqueSort (e), H.test (a) && e.reverse ()), this.pushStack (e)}}); var K = / [^ \ x20 \ t \ r \ n \ f] + / g; función L (a) {var b = {}; devolver r.each (a.match (K) || [], función (a,c) {b [c] =! 0}), b} r.Callbacks = function (a) {a = "string" == typeof a? L (a): r.extend ({}, a); var b, c, d, e, f = [], g = [], h = -1, i = función () {para (e = a.once, d = b =! 0; g.length; h = -1) {c = g.shift (); while (++ h <f.length) f [h] .apply (c [0], c [1]) ===! 1 && a.stopOnFalse && (h = f .length, c =! 1)} a.memory || (c =! 1), b =! 1, e && (f = c? []: "")}, j = {add: function () {return f && (c &&! b && (h = f.length-1, g.push (c)), función d (b) {r.each (b, function (b, c) {r.isFunction (c)? a. único && j.has (c) || ​​f.push (c): c && c.length && "string"! == r.type (c) && d (c)})} (argumentos), c &&! b && i ()), this} , remove: function () {return r.each (argumentos, función (a, b) {var c; while ((c = r.inArray (b, f, c))> - 1) f.splice (c, 1), c <= h && h -}), this}, tiene: function (a) {return a? R.inArray (a, f)> - 1: f.length> 0}, empty: function () { volver f &una vez memoria "), 0," resuelto "], [" rechazar "," fallar ", r.Callbacks (" una vez memoria "), r.Callbacks (" once memoria "), 1," rechazado "]], d = "pendiente", e = {estado: función () {retorno d}, siempre: función () {retorno f.done (argumentos). fallo (argumentos), este}, "captura": función (a) {retorno e.then (null, a)}, pipe: function () {var a = argumentos; return r.Dferfer (función (b) {r.each (c, function (c, d) {var e = r.isFunction (a [d [4]]) && a [d [4]]; f [d [1]] (función () {var a = e && e.apply (esto, argumentos); a && r.isFunction (a.promise)? a.promise (). progress (b.notify) .done (b.resolve) .fail (b.reject): b [d [0] + "With"] (this, e? [a]: argumentos)} )}), a = null}). promise ()}, luego: function (b, d, e) {var f = 0; function g (b, c, d, e) {return function () {var h = esto, i = argumentos, j = función () {var a, j; if (! (b <f)) {si (a = d.apply (h, i), a === c.promise ()) lanza un nuevo TypeError ("Auto resolución ajustable de Thenable"); j = a && ("object" == typeof a || "function" == typeof a) && a.then, r.isFunction (j)? e? j.call (a, g (f, c, M, e), g (f, c, N, e)) :( f ++, j.call (a, g (f, c, M, e), g (f, c, N, e), g (f, c, M, c.notifyWith)) )(( d! == M && (h = void 0, i = [a]), (e || c. resolverWith) (h, i))}}, k = e? j: function () {try {j ()} catch (a) {r.Deferred.exceptionHook && r.Deferred.exceptionHook (a, k.stackTrace), b +1> = f && (d! == N && (h = void 0, i = [a]), c.rejectWith (h, i))}}; b? K () :( r.Deferred.getStackHook && (k .stackTrace = r.Deferred.getStackHook ()), a.setTimeout (k))}} return r.Deferred (function (a) {c [0] [3] .add (g (0, a, r.isFunction (e)? e: M, a.notifyWith)), c [1] [3] .add (g (0, a, r.isFunction (b)? b: M)), c [2] [3] .add (g (0, a, r.isFunction (d)? d: N))). promise ()}, promise: function (a) {return null! = a? r.extend (a, e) : e}}, f = {}; devolver r.cada (c, función (a, b) {var g = b [2], h = b [5]; e [b [1]] = g.add, h && g.add (función () {d = h} , c [3-a] [2] .disable, c [0] [2] .lock), g.add (b [3] .fire), f [b [0]] = función () {return f [b [0] + "Con"] (este === f? void 0: this, argumentos), f} [b [0] + "With"] = g.fireWith}), e.promise ( f), b && b.call (f, f), f}, cuando: function (a) {var b = discusiones.longitud, c = b, d = Array (c), e = f.call (argumentos), g = r.Deferred (), h = function (a) {return function (c) {d [a] = this, e [a] = argumentos.length> 1? f.call (argumentos): c, - b || g.resolveWith (d, e)}}; if (b <= 1 && (O (a, g.done (h (c)) .resolver, g.reject), "pendiente" === g.state () || r.isFunction (e [c] && e [c] .then))) devuelve g.then (); mientras que (c -) O (e [c], h (c), g.reject) ; return g.promise ()}}); var P = / ^ (Eval | Internal | Range | Reference | Syntax | Type | URI) Error $ /; r.Deferred.exceptionHook = function (b, c) {a. consola && a.console.warn && b &readyException (a)}), this}, r.extend ({isReady:! 1, readyWait: 1, holdReady: function (a) {a? r.readyWait ++: r.ready (! 0)}, ready: function ( a) {(a ===! 0? - r.readyWait: r.isReady) || (r.isReady =! 0, a! ==! 0 && - r.readyWait> 0 || Q.resolveWith ( d, [r]))}}), r.ready.then = Q.then; function R () {d.removeEventListener ("DOMContentLoaded", R),readyException (a)}), this}, r.extend ({isReady:! 1, readyWait: 1, holdReady: function (a) {a? r.readyWait ++: r.ready (! 0)}, ready: function ( a) {(a ===! 0? - r.readyWait: r.isReady) || (r.isReady =! 0, a! ==! 0 && - r.readyWait> 0 || Q.resolveWith ( d, [r]))}}), r.ready.then = Q.then; function R () {d.removeEventListener ("DOMContentLoaded", R),
nodeType &&! V.get (f, "hasDataAttrs"))) {c = g.length; mientras que (c -) g [c] && (d = g [c] .name, 0 === d.indexOf ( "data -") && (d = r.camelCase (d.slice (5)), $ (f, d, e [d]))); V.set (f, "hasDataAttrs",! 0)} return e} devuelve "object" == typeof a? this.each (function () {W.set (this, a)}): S (this, function (b) {var c; if (f && void 0 === b ) {if (c = W.get (f, a), void 0! == c) return c; if (c = $ (f, a), void 0! == c) return c} else this.each (function () {W.set (this, a, b)})}, null, b, argument.length> 1, null,! 0)}, removeData: function (a) {return this.each (function ( ) {W.remove (this, a)})}}), r.extend ({queue: function (a, b, c) {var d; si (a) devuelve b = (b || "fx") + "cola", d = V.get (a, b), c && (! d || r.isArray (c)? d = V.access (a, b, r.makeArray (c)): d.push (c)), d || []}, dequeue: function (a, b) {b = b || "fx"; var c = r.queue (a, b), d = c.length, e = c.shift (), f = r._queueHooks (a, b), g = function () {r.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" = == b && c.unshift ("inprogress"), eliminar f.stop, e.call (a, g, f)) ,! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; devolver V.get (a, c) || ​​V.access (a, c, {empty: r.Callbacks ("once memory"). add (function () {V.remove (a, [ b + "cola", c])})})}}), r.fn.extend ({queue: function (a, b) {var c = 2; devuelve "string"! = typeof a && (b = a, a = "fx", c -), los argumentos.longitud <c? r.queue (este [0], a): void 0 === b? this: this.each (function () {var c = r .queue (this, a, b); r._queueHooks (this, a), "fx" === a && "inprogress"! == c [0] && r.dequeue (this, a)})}, dequeue: function (a) {return this.each (function () {r.dequeue (this, a)})}, clearQueue:función (a) {devolver this.queue (a || "fx", [])}, promesa: función (a, b) {var c, d = 1, e = r.Deferred (), f = this, g = this.length, h = function () {- d || e.resolveWith (f, [f])}; "string"! = typeof a && (b = a, a = void 0), a = a || "fx"; while (g -) c = V.get (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty.add (h)); return h (), e.promise (b)}}); var _ = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source aa = new RegExp ("^ (?: ([+ -]) = |) (" + _ + ") ([az%] *) $", "i"), ba = ["Top", "Right "," Inferior "," Izquierda "], ca = función (a, b) {return a = b || a," none "=== a.style.display ||" "=== a.style. display && r.contains (a.ownerDocument, a) && "none" === r.css (a, "display")}, da = function (a, b, c, d) {var e, f, g = { }; para (f en b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []);style && (c = d.style.display, b? ("none" === c && (e [f] = V.get (d, "display") || null, e [f] || (d.style .display = "")), "" === d.style.display && ca (d) && (e [f] = ga (d))): "none"! == c && (e [f] = "none ", V.set (d," display ", c))); para (f = 0; f <g; f ++) null! = E [f] && (a [f] .style.display = e [f ]); return a} r.fn.extend ({show: function () {return ha (this,! 0)}, hide: function () {return ha (this)}, toggle: function (a) {return "boolean" == typeof a? a? this.show (): this.hide (): this.each (function () {ca (this)? r (this) .show (): r (this) .hide ()})}}); var ia = / ^ (?: casilla de verificación | radio) $ / i, ja = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] +) / i, ka = / ^ $ | \ / (?: java | ecma) script / i, la = {opción: [1, "<select multiple = 'multiple'>", "</select>"] , thead: [1, "<table>", "</table>"], col: [2," <table> <colgroup> "," </colgroup> </table> "], tr: [2," <table> <tbody> "," </tbody> </ table> "], td: [3," <table> <tbody> <tr> "," </tr> </tbody> </table> "], _ default: [0," "," "]} ; la.optgroup = la.option, la.tbody = la.tfoot = la.colgroup = la.caption = la.thead, la.th = la.td; función ma (a, b) {var c; retorno c = "undefined"! = typeof a.getElementsByTagName? a.getElementsByTagName (b || "*"): "undefined"! = typeof a.querySelectorAll? a.querySelectorAll (b || "*"):] === b || b && r.nodeName (a, b)? r.merge ([a], c): c} función na (a, b) {para (var c = 0, d = a.length; c <d; c ++) V.set (a [c], "globalEval",! b || V.get (b [c], "globalEval"))} var oa = / <| & #? \ w +; función pa (a, b,c, d, e) {para (var f, g, h, i, j, k, l = b.createDocumentFragment (), m = [], n = 0, o = a.length; n <o; n ++ ) if (f = a [n], f || 0 === f) if ("object" === r.type (f)) r.merge (m, f.nodeType? [f]: f) ; else if (oa.test (f)) {g = g || l.appendChild (b.createElement ("div")), h = (ja.exec (f) || ["", ""])) [1] .toLowerCase (), i = la [h] || la._default, g.innerHTML = i [1] + r.htmlPrefilter (f) + i [2], k = i [0]; mientras k -) g = g.lastChild; r.merge (m, g.childNodes), g = l.firstChild, g.textContent = ""} else m.push (b.createTextNode (f)); l.textContent = "", n = 0; mientras que (f = m [n ++]) if (d && r.inArray (f, d)> - 1) e && e.push (f); si no (j = r.contains (f.ownerDocument , f), g = ma (l.appendChild (f), "script"), j && na (g), c) {k = 0; while (f = g [k ++]) ka.test (f.type || "") && c.push (f)} return l}! function () {var a = d.createDocumentFragment (), b = a.appendChild (d.createElement ("== typeof c? (e = d, d = void 0) :( e = d, d = c, c = void 0)), e ===! 1) e = va; else if (! e) return a; return 1 === f && (g = e, e = function (a) {return r (). off (a), g.apply (this, argumentos)}, e.guid = g.guid || ( g.guid = r.guid ++)), a.each (function () {r.event.add (this, b, e, d, c)})} r.event = {global: {}, add: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, n, o, p, q = V.get (a); if (q) {c .handler && (f = c, c = f.handler, e = f.selector), e && r.find.matchesSelector (qa, e), c.guid || (c.guid = r.guid ++), (i = q .events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function (b) {return "undefined"! = typeof r && r.event.triggered! == b.type? r.event.dispatch.apply (a, argumentos): void 0}), b = (b || ""). match (K) || [""], j = b.length ; mientras que (j -) h = ta.exec (b [j]) || [], n = p = h [1], o = (h [2] || ""). split ("." ) .sort (), n && (l = r.event.special [n] || {}, n = (e? l.delegateType: l.bindType) || n, l = r.event.special [n] || {}, k = r.extend ({type: n, origType: p, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && r.expr.match. needsContext.test (e), espacio de nombres: o.join (".")}, f), (m = i [n]) || (m = i [n] = [], m.delegateCount = 0, l .setup && l.setup.call (a, d, o, g)! ==! 1 || a.addEventListener && a.addEventListener (n, g)), l.add && (l.add.call (a, k), k .handler.guid || (k.handler.guid = c.guid)), e? m.splice (m.delegateCount ++, 0, k): m.push (k), r.event.global [n] = ! 0)}}, eliminar: función (a, b, c, d, e) {var f, g, h, i, j, k, l, m, n, o, p, q = V. hasData ( a) && V.get (a); if (q && (i = q.events)) {b = (b || ""). match (K) || [""], j = b.length; while ( j -) si (h = ta.exec (b [j]) || [], n = p = h [1], o = (h [2] || ""). split (".") .sort (), n) {l = r.event.special [n] || {}, n = (d? l.delegateType: l.bindType) || n, m = i [n] || [] , h = h [2] && nuevo RegExp ("(^ | \\.)" + o.join ("\\. (?:. * \\. |) ") +" (\\. | $) "), g = f = m.length; mientras que (f -) k = m [f] ,! e && p! == k.origType || c && c.guid! == k.guid || h &&! h.test (k.namespace) || d & & d! == k.selector && ("**"! == d ||! k.selector) || (m.splice (f, 1), k.selector && m.delegateCount -, l.remove && l.remove.call (a, k)); g &&! m.length && (l.teardown && l.teardown.call (a, o, q.handle)! ==! 1 || r.removeEvent (a, n, q.handle), eliminar i [n])} else for (n en i) r.event.remove (a, n + b [ j], c, d,! 0); r.isEmptyObject (i) && V.remove (a, "manejar eventos")}}, dispatch: function (a) {var b = r.event.fix (a), c, d, e, f, g, h, i = nueva matriz (argumentos.longitud), j = (V.get (este, "eventos") || {}) [b.type] || [], k = r.event.special [b.type] || {}; para (i [0] = b, c = 1; c <argumentos.longitud; c ++) i [c] = argumentos [c]; if ( b.delegateTarget = this,! k.preDispatch || k.preDispatch.call (this, b)! ==!1) {h = r.event.handlers.call (this, b, j), c = 0; while ((f = h [c ++]) &&! B.isPropagationStopped ()) {b.currentTarget = f.elem , d = 0; while ((g = f.handlers [d ++]) &&! b.isImmediatePropagationStopped ()) b.rnamespace &&! b.rnamespace.test (g.namespace) || (b.handleObj = g, b. data = g.data, e = ((r.event.special [g.origType] || {}). handle || g.handler) .apply (f.elem, i), void 0! == e && ( b.result = e) ===! 1 && (b.preventDefault (), b.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (this, b), b.result}), handlers: function ( a, b) {var c, d, e, f, g, h = [], i = b.delegateCount, j = a.target; if (i && j.nodeType &&! ("click" === a.type && a. botón> = 1)) para (; j! == esto; j = j.parentNode || esto) if (1 === j.nodeType && ("click"! == a.type || j.disabled! = =! 0)) {para (f = [], g = {}, c = 0; c <i; c ++) d = b [c], e = d.selector + "", void 0 === g [ mi]&&(g [e] = d.needsContext? r (e, this) .index (j)> - 1: r.find (e, this, null, [j]). length), g [e] && f.push (d); f.length && h.push ({elem: j, handlers: f})} return j = this, i <b.length && h.push ({elem: j, handlers: b.slice (i)}), h}, addProp: function (a, b) {Object.defineProperty (r.Event.prototype, a, {enumerable:! 0, configurable:! 0, get: r.isFunction (b)? function () {if ( this.originalEvent) return b (this.originalEvent)}: function () {if (this.originalEvent) devuelve this.originalEvent [a]}, set: function (b) {Object.defineProperty (this, a, {enumerable: ! 0, configurable:! 0, grabable:! 0, valor: b})}})}, corregir: función (a) {devolver a [r.expando]? A: nuevo r.Event (a)}, especial : {load: {noBubble:! 0}, focus: {trigger: function () {if (this! == wa () && this.focus) devuelve this.focus () ,! 1}, delegateType: "focusin"} , blur: {trigger: function () {if (this === wa () && this.blur) devuelve this.blur () ,! 1},delegateType: "focusout"}, haga clic en: {trigger: function () {if ("checkbox" === this.type && this.click && r.nodeName (this, "input")) devuelva this.click () ,! 1}, _default: function (a) {return r.nodeName (a.target, "a")}}, beforeunload: {postDispatch: function (a) {void 0! == a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)}}}}, r.removeEvent = function (a, b, c) {a.removeEventListener && a.removeEventListener (b, c)}, r.Event = function (a, b) {devuelve esta instancia de r. ¿Evento? (A && a.type? (This.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue ===! 1? Ua: va , this.target = a.target && 3 === a.target.nodeType? a.target.parentNode: a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget): this.type = a, segundo&& r.extender (this, b), this.timeStamp = a && a.timeStamp || r.now (), void (this [r.expando] =! 0)): new r.Event (a, b)}, r .Event.prototype = {constructor: r.Event, isDefaultPrevented: va, isPropagationStopped: va, isImmediatePropagationStopped: va, isSimulated:! 1, preventDefault: this.isSimulated && a.preventDefault ()}, stopPropagation: function () {var a = this.originalEvent; this.isPropagationStopped = ua, a &&! this.isSimulated && a.stopPropagation ()), stopImmediatePropagation: function originalEvent; this.isImmediatePropagationStopped = ua, a &&! this.isSimulated && a.stopImmediatePropagation (), this.stopPropagation ()}}, r.each ({altKey:! 0, bubbles:! 0, cancelable:! 0, changedTouches:! 0 , ctrlKey:! 0, detalle:! 0, eventPhase:! 0, metaKey:! 0, pageX:! 0, pageY:! 0, shiftKey:! 0, ver:! 0,"char":! 0, charCode:! 0, key:! 0, keyCode:! 0, button:! 0, buttons:! 0, clientX:! 0, clientY:! 0, offsetX:! 0, offsetY :! 0, pointerId:! 0, pointerType:! 0, screenX:! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, toca:! 0, que: function (a) {var b = a.button ; return null == a.which && ra.test (a.type)? null! = a.charCode? a.charCode: a.keyCode:! a.which && void 0! == b && sa.test (a.type)? 1 & b? 1: 2 & b? 3: 4 & b? 2: 0: a.which}}, r.event.addProp), r.each ({mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "puntero"}, función (a, b) {r.event.special [a] = {delegateType: b, bindType: b, handle: function (a) {var c, d = this, e = a.relatedTarget, f = a.handleObj; return e && (e === d || r.contains (d, e)) || (a.type = f.origType, c = f.handler.apply (this, argumentos), a .type = b), c}}}), r.fn.extend ({on: function (a, b, c,off (e, b, a [e]); devolver este} return b! ==! 1 && "function"! = typeof b || (c = b, b = void 0), c ===! 1 && (c = va), this.each (function () {r.event.remove (this, a, c, b)})}}); var ya = / <(?! area | br | col | embed | hr | img | input | link | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ />/gi,za=/<script|<style|<link/i,Aa=/checked\s*(?:[^=◆|=\s*.checked.)/i,Ba=/^true \ / (. *) /, Ca = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; function Da (a, b) {return r.nodeName (a, "table") && r.nodeName (11! == b.nodeType? B: b.firstChild, "tr")? A.getElementsByTagName ("tbody") [ 0] || a: a} función Ea (a) {return a.type = (null! == a.getAttribute ("type")) + "/" + a.type, a} function Fa (a) { var b = Ba.exec (a.type); return b? a.type = b [1]: a.removeAttribute ("type"), a} función Ga (a, b) {var c, d, e, f, g, h, i, j; if (1 === b.nodeType) {si (V.hasData (a) && (f = V.access (a), g = V.set) , j = f.eventos)) {eliminar g.handle, g.events = {}; para (e en j) para (c = 0, d = j [e] .length; c <d; c ++) r. event.add (b, e, j [e] [c])} W.hasData (a) && (h = W.access (a), i = r.else Ga (a, h); devuelve g = ma (h, "script"), g.length> 0 && na (g,! i && ma (a, "script")), h}, cleanData: function (a) {for (var b, c, d, e = r.event.special, f = 0; void 0! == (c = a [f]); f ++) if (T (c)) {if (b = c [ V.expando]) {if (b.events) para (d in b.events) e [d]? R.event.remove (c, d): r.removeEvent (c, d, b.handle); c [V.expando] = void 0} c [W.expando] && (c [W.expando] = void 0)}}}), r.fn.extend ({detach: function (a) {return Ja (this , a,! 0)}, eliminar: function (a) {return Ja (this, a)}, text: function (a) {return S (this, function (a) {return void 0 === a? r .text (this): this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = a)})}, nulo, a, argumentos.longitud)}, añadir: función () {devolver Ia (esto, argumentos, función (a) {si (1 === this.nodeType || 11 === this.nodeType || 9 = == this.nodeType) {var b = Da (this, a); b.appendChild (a)}})}, prepend:function () {return Ia (this, argumentos, function (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Da ( this, a); b.insertBefore (a, b.firstChild)}})}, before: function () {return Ia (this, argumentos, function (a) {this.parentNode && this.parentNode.insertBefore (a, this) })}, after: function () {return Ia (this, argumentos, function (a) {this.parentNode && this.parentNode.insertBefore (a, this.nextSibling)})}, empty: function () {for (var a , b = 0; null! = (a = this [b]); b ++) 1 === a.nodeType && (r.cleanData (ma (a,! 1)), a.textContent = ""); devuélvalo }, clone: ​​function (a, b) {return a = null! = a && a, b = null == b? a: b, this.map (function () {return r.clone (this, a, b)} )}, html: function (a) {return S (this, function (a) {var b = this [0] || {}, c = 0, d = this.length; if (void 0 === a && 1 === b.nodeType) devuelve b.innerHTML; if ("string" == typeof a &&! za.test (a) &px) [az%] + $ "," i "), Ma = función (b) {var c = b.ownerDocument.defaultView; return c && c.opener || (c = a), c.getComputedStyle (b)} ;! function () {function b () {if (i) {i.style.cssText = "tamaño de caja: borde-cuadro; posición: relativa; pantalla: bloque; margen: automático; borde: 1px; relleno: 1px ; parte superior: 1%; ancho: 50% ", i.innerHTML =" ", qa.appendChild (h); var b = a.getComputedStyle (i); c =" 1% "! == b.top, g = "2px" === b.marginLeft, e = "4px" === b.width, i.style.marginRight = "50%", f = "4px" === b.marginRight, qa.removeChild ( h), i = nulo}} var c, e, f, g, h = d.createElement ("div"), i = d.createElement ("div"); i.style && (i.style.backgroundClip = " content-box ", i.cloneNode (! 0) .style.backgroundClip =" ", o.clearCloneStyle =" content-box "=== i.style.backgroundClip, h.style.cssText =" border: 0; width :8px; altura: 0; arriba: 0; izquierda: -9999px; relleno: 0; margen superior: 1px; posición: absoluta ", h.appendChild (i), r.extend (o, {pixelPosition: function () { return b (), c}, boxSizingReliable: function () {return b (), e}, pixelMarginRight: function () {return b (), f}, reliableMarginLeft: function () {return b (), g}} ))} (); función Na (a, b, c) {var d, e, f, g, h = a.style; devolver c = c || Ma (a), c && (g = c.getPropertyValue ( b) || c [b], ""! == g || r.contains (a.ownerDocument, a) || (g = r.style (a, b)) ,! o.pixelMarginRight () && La. test (g) && Ka.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0! == g? g + "": g} function Oa (a, b) {return {get: function () {return a ()? void eliminar this.get: (this.get = b) .apply (this, argumentos)}}} var Pa = / ^ (none | table (?! - c [ea]). +) /, Qa = {posición: "absoluta", visibilidad:(g + = r.css (a, "borde" + ba [f] + "Ancho",! 0, e))); devolver la función ga Xa (a, b, c) {var d, e =! 0 , f = Ma (a), g = "cuadro de borde" === r.css (a, "boxSizing",! 1, f); if (a.getClientRects (). length && (d = a.getBoundingClientRect ( ) [b]), d <= 0 || null == d) {if (d = Na (a, b, f), (d <0 || null == d) && (d = a.style [ b]), La.test (d)) devuelve d; e = g && (o.boxSizingReliable () || d === a.style [b]), d = parseFloat (d) || 0} return d + Wa (a, b, c || (g? "Border": "content"), e, f) + "px"} r.extend ({cssHooks: {opacity: {get: function (a, b) { if (b) {var c = Na (a, "opacidad"); return "" === c? "1": c}}}}, cssNumber: {animationIterationCount:! 0, columnCount:! 0, fillOpacity: ! 0, flexGrow:! 0, flexShrink:! 0, fontWeight:! 0, lineHeight:! 0, opacity:! 0, order:! 0, huérfanos:! 0, widows:! 0, zIndex:! 0, zoom: ! 0}, cssProps: {"float": "cssFloat"}, estilo:g && "obtener" en g && (e = g.get (a,! 0, c)), void 0 === e && (e = Na (a, b, d)), "normal" === e && b en Ra && (e = Ra [b]), "" === c || c? (f = parseFloat (e), c ===! 0 || isFinite (f)? f || 0: e): e} }), r.each (["height", "width"], function (a, b) {r.cssHooks [b] = {get: function (a, c, d) {if (c) return! Pa .test (r.css (a, "display")) || a.getClientRects (). length && a.getBoundingClientRect (). width? Xa (a, b, d): da (a, Qa, function () {return Xa (a, b, d)})}, establecer: función (a, c, d) {var e, f = d && Ma (a), g = d && Wa (a, b, d, "cuadro de borde" == = r.css (a, "boxSizing",! 1, f), f); devuelve g && (e = aa.exec (c)) && "px"! == (e [3] || "px") && (a.style [b] = c, c = r.css (a, b)), Va (a, c, g)}}}), r.cssHooks.marginLeft = Oa (o.reliableMarginLeft, function ( a, b) {if (b) return (parseFloat (Na (a, "marginLeft"c) {para (var d, e = (hb.tweeners [b] || []). concat (hb.tweeners ["*"]), f = 0, g = e.length; f <g; f ++ ) si (d = e [f] .call (c, b, a)) devuelve d} función fb (a, b, c) {var d, e, f, g, h, i, j, k, l = "ancho" en b || "altura" en b, m = esto, n = {}, o = a.style, p = a.nodeType && ca (a), q = V.get (a, "fxshow") ; c.queue || (g = r._queueHooks (a, "fx"), null == g.unqueued && (g.unqueued = 0, h = g.empty.fire, g.empty.fire = function () {g.unqueued || h ()}), g.unqueued ++, m.always (function () {m.always (function () {g.unqueued -, r.queue (a, "fx"). length || g.empty.fire ()})})); para (d en b) if (e = b [d], _ a.test (e)) {if (eliminar b [d], f = f | | "toggle" === e, e === (p? "hide": "show")) {if ("show"! == e ||! q || void 0 === q [d] ) continúa; p =! 0} n [d] = q && q [d] || r.style (a, d)} if (i =! r.isEmptyObject (b), i ||! r.isEmptyObject (n) ) {l && 1 === a.nodeType && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = q && q.display, null == j && (j = V.get (a, "display")), k = r.css (a, " muestra ")," ninguno "=== k && (j? k = j: (ha ([a] ,! 0), j = a.style.display || j, k = r.css (a," display "), ha ([a]))), (" inline "=== k ||" inline-block "=== k && null! = j) &&" none "=== r.css (a," float ") && (i || (m.done (function () {o.display = j}), null == j && (k = o.display, j =" none "=== k?" ": k) ), o.display = "inline-block")), c.overflow && (o.overflow = "hidden", m.always (function () {o.overflow = c.overflow [0], o.overflowX = c .overflow [1], o.overflowY = c.overflow [2]})), i =! 1; para (d in n) i || (q? "hidden" en q && (p = q.hidden): q = V.access (a, "fxshow", {display: j}), f && (q.hidden =! p), p && ha ([a] ,! 0), m.done (function () {p || ha ([a]), V.remove (a, "fxshow"); para (d in n) r.style (a, d, n [d])})), i = eb (p? q [d]: 0, d, m), d en q || (q [d] = i.start, p && (i.end = i.start, i.start = 0)) }} función gb (a, b) {var c, d, e, f, g; para (c in a) if (d = r.camelCase (c), e = b [d], f = a [c ], r.isArray (f) && (e = f [1], f = a [c] = f [0]), c! == d && (a [d] = f, eliminar a [c]), g = r.cssHooks [d], g && "expandir" en g) {f = g.expand (f), eliminar a [d]; para (c en f) c en a || (a [c] = f [c], b [c] = e)} else b [d] = e} función hb (a, b, c) {var d, e, f = 0, g = hb.prefilters.length, h = r .Deferred (). Always (function () {delete i.elem}), i = function () {if (e) return! 1; for (var b = Za || cb (), c = Math.max ( 0, j.startTime + j.duration-b), d = c / j.duration || 0, f = 1-d, g = 0, i = j.tweens.length; g <i; g ++) j. tweens [g] .run (f); return h.notifyWith (a, [j, f, c]), f <1 && i? c: (h.resolveWith (a, [j]) ,! 1)}, j = h.promise ({elem: a, props: r.extend ({}, b), opts: r.extend (! 0,siempre (j.opts.always)} r.Animation = r.extend (hb, {tweeners: {"*": [function (a, b) {var c = this.createTween (a, b); devuelva ea ( c.elem, a, aa.exec (b), c), c}]}, tweener: función (a, b) {r.isFunction (a)? (b = a, a = ["*"]) : a = a.match (K); para (var c, d = 0, e = a.length; d <e; d ++) c = a [d], hb.tweeners [c] = hb.tweeners [c ] || [], hb.tweeners [c] .unshift (b)}, prefiltros: [fb], prefilter: función (a, b) {b? hb.prefilters.unshift (a): hb.prefilters.push (a)}}), r.speed = función (a, b, c) {var e = a && "objeto" == tipo de un? r.extendido ({}, a): {completo: c ||! c && b || r.isFunction (a) && a, duración: a, suavizado: c && b || b &&! r.isFunction (b) && b}; return r.fx.off || d.hidden? e.duration = 0: "número "! = typeof e.duration && (e.duration en r.fx.speeds? e.duration = r.fx.speeds [e.duration]: e.duration = r.fx.speeds._default), null! = e .queue && e.queue! ==! 0 || (e.queue = "fx"), e.old = e.complete, e.complete = function () {r.isFunction (e.old) && e.old.call (this), e.queue && r.dequeue (this, e. cola)}, e}, r.fn.extend ({fadeTo: function (a, b, c, d) {return this.filter (ca) .css ("opacity", 0) .show (). end ( ) .animate ({opacidad: b}, a, c, d)}, animate: function (a, b, c, d) {var e = r.isEmptyObject (a), f = r.speed (b, c) , d), g = función () {var b = hb (this, r.extend ({}, a), f); (e || V.get (this, "finish")) && b.stop (! 0)}; devolver g.finish = g, e || f.queue ===! 1? This.each (g): this.queue (f.queue, g)}, stop: function (a, b, c) {var d = función (a) {var b = a.stop; delete a.stop, b (c)}; devuelve "string"! = typeof a && (c = b, b = a, a = void 0 ), b && a! ==! 1 && this.queue (a || "fx", []), this.each (function () {var b =! 0, e = null! = a && a + "queueHooks", f = r. temporizadores, g = V.get (esto); if (e) g [e] && g [e] .stop &&d (g [e]); else para (e en g) g [e] && g [e] .stop && ab.test (e) &&d (g [e]); para (e = f.length; e--; ) f [e] .elem! == este || null! = a && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1, f.splice ( e, 1)) ;! b && c || r.dequeue (this, a)})}, finish: function (a) {return a! ==! 1 && (a = a || "fx"), this.each (function () {var b, c = V.get (this), d = c [a + "queue"], e = c [a + "queueHooks"], f = r.timers, g = d? d.length : 0; para (c.finish =! 0, r.queue (this, a, []), e && e.stop && e.stop.call (this,! 0), b = f.length; b -;) f [b] .elem === este && f [b] .queue === a && (f [b] .anim.stop (! 0), f.splice (b, 1)) para (b = 0; b < g; b ++) d [b] && d [b] .finish && d [b] .finish.call (this); delete c.finish})}}), r.each (["toggle", "show", "hide "], función (a, b) {var c = r.fn [b]; r.fn [b] = función (a, d, e) {return null == a ||" boolean "_default: 400}, r.fn.delay = function (b, c) {return b = r.fx? r.fx.speeds [b] || b: b, c = c || "fx", esto. cola (c, función (c, d) {var e = a.setTimeout (c, b); d.stop = función () {a.clearTimeout (e)}})}, función () {var a = d .createElement ("input"), b = d.createElement ("select"), c = b.appendChild (d.createElement ("option")); a.type = "checkbox", o.checkOn = ""! == a.value, o.optSelected = c.selected, a = d.createElement ("input"), a.value = "t", a.type = "radio", o.radioValue = "t" == = a.valor} (); var ib, jb = r.expr.attrHandle; r.fn.extend ({attr: function (a, b) {return S (este, r.attr, a, b, argumentos. length> 1)}, removeAttr: function (a) {return this.each (function () {r.removeAttr (this, a)})}}), r.extend ({attr: function (a, b, c ) {var d, e, f = a.nodeType; if (3! == f && 8! == f && 2! == f) devuelve "undefined" == typeof a.
aplicación / x-www-form-urlencoded; charset = UTF-8 ", acepta: {" * ": Hb, texto:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", json:" application / json , text / javascript "}, contenidos: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml:" responseXML ", texto:" responseText " , json: "responseJSON"}, converters: {"* text": String, "text html":! 0, "text json": JSON.parse, "text xml": r.parseXML}, flatOptions: {url: ! 0, contexto:! 0}}, ajaxSetup: function (a, b) {return b? Lb (Lb (a, r.ajaxSettings), b): Lb (r.ajaxSettings, a)}, ajaxPrefilter: Jb ( Fb), ajaxTransport: Jb (Gb), ajax: function (b, c) {"object" == typeof b && (c = b, b = void 0), c = c || {}; var e, f, g, h, i, j, k, l, m, n, o = r.ajaxSetup ({}, c), p = o.context || o, q = o.context && (p.nodeType || p.